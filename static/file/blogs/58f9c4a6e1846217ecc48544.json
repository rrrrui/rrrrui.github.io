{
  "title" : "Angular学习日志（依赖注入和Service们）",
  "author" : "Arui",
  "type" : "前端学习",
  "body" : "<h2><span style=\"font-weight: bold;\">angular的Service们</span></h2><p>ng可注入的Service类型有provider、factory、service、value等。这些注入的对象都是单例，在声明的时候这些对象就都被创建（实例化的时间是不一样的），然后哪里需要就注入到哪里。供应商$provider提供方法来创建不同形式可注入的服务（Services）。下图画出了它们直间的关系，接下来详细了解一下（以service、factory、provider为例）。</p><p><img src=\"http://oo0tynh66.bkt.clouddn.com/$provider.png\" style=\"max-width: 100%;\"></p><h2>用法：</h2><h3>service：</h3><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-keyword\">var</span> app = angular.module(<span class=\"hljs-string\">\"app\"</span>, [])\napp.service(<span class=\"hljs-string\">'myService'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">'arui'</span>;\n    <span class=\"hljs-keyword\">this</span>.age = <span class=\"hljs-number\">24</span>;\n});\napp.run([<span class=\"hljs-string\">\"myService\"</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">myService</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(myService.name)<span class=\"hljs-comment\">//'arui'</span>\n}])</code></pre><p>service是通过new关键字来实例化的对象，因为它是一个单例的存在所以无论在哪里注入它们都是同一个service对象，然后可以获取和操作这个对象的属性。所以service比较适合做共享数据存放操作。（问：现在的流行的单向数据流是不是就是这个思想，然后增加了更多管理和分发的操作？）。</p><h3>factory:</h3><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">app.factory(<span class=\"hljs-string\">'myFactory'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"arui\"</span>;\n  <span class=\"hljs-keyword\">return</span> {\n    getName: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-keyword\">return</span> name\n    },\n    setName: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">val</span>) </span>{\n      name = val;\n    }\n  }\n});\napp.run([<span class=\"hljs-string\">\"myFactory\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">myFactory</span>) </span>{\n  myFactory.setName(<span class=\"hljs-string\">\"Arui\"</span>)\n  <span class=\"hljs-built_in\">console</span>.log(myFactory.getName()) <span class=\"hljs-comment\">//\"Arui\"</span>\n}]);</code></pre><p>factory是最常用的服务，它创建一个对象然后给这个对象添加属性和方法然后将这个对象返回。我觉得它更像是一个闭包通过暴露API然后来操作内部私有属性。</p><h3>provider:</h3><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">app.provider(<span class=\"hljs-string\">'myProvider'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n  <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">\"Arui\"</span>;\n  <span class=\"hljs-keyword\">this</span>.$get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      getName: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> self.name\n      }\n    }\n  }\n});\napp.config([<span class=\"hljs-string\">'myProviderProvider'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">myProviderProvider</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(myProviderProvider.name = <span class=\"hljs-string\">\"arui\"</span>)\n}]);\napp.run([<span class=\"hljs-string\">\"myProvider\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">myProvider</span>) </span>{\n  myProvider.getName()<span class=\"hljs-comment\">//\"arui\"</span>\n}]);</code></pre><p>provider它也是通过new关键字来实例化的，但是它注入的时候注入了$get的返回值这点和factory一样，provider特殊的地方是它在启动之前是可配置的。可配置的话就可以有很多便捷性和灵活性，不同情况不同配置。</p><h2>问题：</h2><h4>1.Service们具体的内部实现是什么样子的？</h4><h4>2.Service们是怎么声明成对象的？</h4><h4>3.为什么provider是可配置的而其它不行？</h4><h4>4.Service是怎么结合注入器运行的？</h4><p>以上问题是我刚接触时最疑惑的地方，下面我们来同过源码来分析一下。</p><h4>Service们具体的内部实现是什么样子的？</h4><p>源码injector部分：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">provider</span>(<span class=\"hljs-params\">name, provider_</span>) </span>{\n  assertNotHasOwnProperty(name, <span class=\"hljs-string\">'service'</span>);\n  <span class=\"hljs-keyword\">if</span> (isFunction(provider_) || isArray(provider_)) {    <span class=\"hljs-comment\">//provider的两种注入方式。数组和直接注入。当从factory或者service进来的时候并不会实例化</span>\n    provider_ = providerInjector.instantiate(provider_);<span class=\"hljs-comment\">//实例化（new）对象，并注入module执行</span>\n  }\n  <span class=\"hljs-keyword\">if</span> (!provider_.$get) {\n    <span class=\"hljs-keyword\">throw</span> $injectorMinErr(<span class=\"hljs-string\">'pget'</span>, <span class=\"hljs-string\">'Provider \\'{0}\\' must define $get factory method.'</span>, name);\n  }\n  <span class=\"hljs-keyword\">return</span> (providerCache[name + providerSuffix] = provider_);<span class=\"hljs-comment\">//注册</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">enforceReturnValue</span>(<span class=\"hljs-params\">name, factory</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">/** @this */</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">enforcedReturnValue</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> result = instanceInjector.invoke(factory, <span class=\"hljs-keyword\">this</span>);<span class=\"hljs-comment\">//注入并返回 新对象。</span>\n    <span class=\"hljs-keyword\">if</span> (isUndefined(result)) {\n      <span class=\"hljs-keyword\">throw</span> $injectorMinErr(<span class=\"hljs-string\">'undef'</span>, <span class=\"hljs-string\">'Provider \\'{0}\\' must return a value from $get factory method.'</span>, name);\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n  };\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factory</span>(<span class=\"hljs-params\">name, factoryFn, enforce</span>) </span>{<span class=\"hljs-comment\">//enforce 默认false</span>\n  <span class=\"hljs-keyword\">return</span> provider(name, {\n    $get: enforce !== <span class=\"hljs-literal\">false</span> ? enforceReturnValue(name, factoryFn) : factoryFn\n  });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">service</span>(<span class=\"hljs-params\">name, constructor</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> factory(name, [<span class=\"hljs-string\">'$injector'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$injector</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> $injector.instantiate(<span class=\"hljs-keyword\">constructor</span>);//实例化\n  }]);\n}</code></pre><p>可以看出接口重载是很多的，就像是jquery事件情况的bind,live,on等等最后走的都是on，不同接口进行一些参数和自己的逻辑处理。service是先走factory然后和factory一样走provider。</p><p>先来看一下provider的内部实现第一个if判断可以区分出来是直接进行的provider声明还是factory的调用，factory调用provider的第二个参数是object。如果是provider直接声明的话providerInjector.instantiate(provider_)会实例化声明的provider成为一个object。就在这里！为什么只有provider实例化了而其他的没有被实例化，这里就是为什么provider可以在config里进行配置，因为提前实例化，返回的对象我们可以在config更改对象里面的属性，所以就可以实现配置化了。但是为什么其他不行呢？等下再说这个问题。</p><p>在provider的最后一行代码&nbsp;providerCache[name + providerSuffix] = provider_ 在providerCache注入了新声明的Service。providerCache是一个什么东西：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">providerCache = {<span class=\"hljs-comment\">//服务提供者缓存</span>\n  $provide: {\n    provider: supportObject(provider),\n    factory: supportObject(factory),\n    service: supportObject(service),\n    value: supportObject(value),\n    constant: supportObject(constant),\n    decorator: decorator\n  }\n},\nproviderInjector = (providerCache.$injector =\n  createInternalInjector(providerCache, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">serviceName, caller</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (angular.isString(caller)) {\n      path.push(caller);\n    }\n    <span class=\"hljs-keyword\">throw</span> $injectorMinErr(<span class=\"hljs-string\">'unpr'</span>, <span class=\"hljs-string\">'Unknown provider: {0}'</span>, path.join(<span class=\"hljs-string\">' &lt;- '</span>));\n  })),\ninstanceCache = {},<span class=\"hljs-comment\">//实例化缓存</span>\nprotoInstanceInjector =\n  createInternalInjector(instanceCache, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">serviceName, caller</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> provider = providerInjector.get(serviceName + providerSuffix, caller); <span class=\"hljs-comment\">//object</span>\n    <span class=\"hljs-keyword\">return</span> instanceInjector.invoke(\n      provider.$get, provider, <span class=\"hljs-literal\">undefined</span>, serviceName);<span class=\"hljs-comment\">//返回Service们</span>\n  }),\ninstanceInjector = protoInstanceInjector;</code></pre><p>注入器部分有2种缓存：providerCache 服务提供者缓存，instanceCache实例化缓存。providerCache 是在Service们声明的时候在provider方法里面<span style=\"background-color: rgb(248, 248, 248); font-family: inherit; font-size: 0.8em;\">providerCache[name + providerSuffix] = provider_ </span>&nbsp;写入的provider为包涵$get属性队象，service和factory为{$get:fn}对象。instanceCache实例化缓存在providerCache 中的对象需要实例化的时候写入的一般是把$get的函数实例化。这就是为什么provider是可配置的原因，因为在providerCache中provider声明的对象其中有除了$get的其他属性，从而我们可以在$get没有实例化之前修改配置该对象其他API达到在外部操作的目的（这是不是面向切面编程？）。在通过new关键字实例化的时候有段代码看了很久才理解了：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-keyword\">new</span> (<span class=\"hljs-built_in\">Function</span>.prototype.bind.apply(fn, args))()</code></pre><p>来解释下这个代码：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">module0,module1,module2,module3</span>) </span>{\n  <span class=\"hljs-comment\">//TODO</span>\n}\n<span class=\"hljs-comment\">//args是固定的时候在new关键字 构造函数的时候我们可以对应传入。</span>\n<span class=\"hljs-keyword\">var</span> fn1 = <span class=\"hljs-keyword\">new</span> fn(module0,module1,module2,module3);\n\n<span class=\"hljs-comment\">//args是不定的 我们要通过关键字apply(arr)来传入一个数组和参数一一对应，那么我们应该来怎么写new关键字呢？</span>\n<span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">module0,module1,module2,module3...</span>) </span>{\n  <span class=\"hljs-comment\">//TODO</span>\n}\n<span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getArgs</span>(<span class=\"hljs-params\">fn</span>)</span>{};\n<span class=\"hljs-comment\">//先通过bind返回一个绑定this和参数的函数然后通过new关键字</span>\n<span class=\"hljs-keyword\">var</span> fn1 = <span class=\"hljs-keyword\">new</span> (<span class=\"hljs-built_in\">Function</span>.prototype.bind.apply(fn, args))()</code></pre><p>感觉js真的是神奇啊，各种奇技淫巧。嗯，学习了。</p><p>以上就解释1.2.3的疑问。Service是怎么注入的，之前写的那篇关于依赖注入有详细解释和源码。</p><h3><font color=\"#008080\">以上是对我个人比较疑惑的地方进行理解和解释，可能很多地方描述和理解不完整不正确，希望不要误导他人。</font></h3><p><br></p><p><br></p>",
  "intro" : "provider,service,value,factory几个Service的异同和用法",
  "time" : "2017-04-27",
  "__v" : 0
}
