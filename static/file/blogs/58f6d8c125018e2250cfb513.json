{
  "title" : "Angular学习日志（依赖注入）",
  "author" : "Arui",
  "type" : "前端学习",
  "body" : "<p>项目中使用的封装 <font color=\"#0000ff\">angular 1.x</font>的前端框架，所以深入学习一下ng。</p><h2>自己用js实现简单的依赖注入</h2><p>对于ng在刚接触时最感兴趣和有疑惑的地方是ng的依赖注入（DI），之前在了解和学习spring的时候有这个感念：控制反转和依赖注入。用js实现依赖注入的方式的思路可以先想一想。ng的写法：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">angular.module(<span class=\"hljs-string\">\"app\"</span>, []).controller(<span class=\"hljs-string\">\"test\"</span>, [<span class=\"hljs-string\">\"myService\"</span>, <span class=\"hljs-string\">\"myFactory\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">myService, myFactoryr</span>) </span>{\n  <span class=\"hljs-comment\">//TODO</span>\n  <span class=\"hljs-comment\">//do someting</span>\n}])</code></pre><p>刚开始用到的时候会有疑惑为什么这样一个函数就自己执行了并且参数变成了所对应的对象。其实这里用的是<font color=\"#ff0000\">apply()</font>。</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">fn.apply(<span class=\"hljs-keyword\">this</span>,args)</code></pre><p>这里的args就是我们所需要的service对象。至于怎么获取了service对象数组，就是使用模块钩子(object[name])的来匹配所需要的service对象：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">angular</span>(<span class=\"hljs-params\"></span>) </span>{};\nangular.module = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.moduleObj = {};\n  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n  <span class=\"hljs-keyword\">return</span> {\n    injector: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) </span>{\n      <span class=\"hljs-keyword\">var</span> argsString = extractArgs(fn)\n      <span class=\"hljs-keyword\">var</span> DIModule = [];\n      argsString.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) </span>{\n        <span class=\"hljs-keyword\">if</span> (!self.moduleObj[val])<span class=\"hljs-keyword\">return</span>;\n        DIModule.push(self.moduleObj[val])\n      })\n      <span class=\"hljs-keyword\">return</span> fn.apply(self, DIModule)\n    },\n    factory: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name, fn</span>) </span>{\n      self.moduleObj[name.trim()] = fn();\n      <span class=\"hljs-keyword\">return</span> self;\n    }\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extractArgs</span>(<span class=\"hljs-params\">fn</span>) </span>{ <span class=\"hljs-comment\">//function.prototype.toString get argsList;</span>\n  <span class=\"hljs-keyword\">var</span> args = fn.toString().match(<span class=\"hljs-regexp\">/^[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>);\n  <span class=\"hljs-keyword\">var</span> argsArr = [];\n  args[<span class=\"hljs-number\">1</span>].split(<span class=\"hljs-string\">','</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">val</span>) </span>{\n    argsArr.push(val.trim());\n  })\n  <span class=\"hljs-keyword\">return</span> argsArr;\n}\n<span class=\"hljs-keyword\">var</span> app = angular.module();\n\napp.factory(<span class=\"hljs-string\">\"test\"</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">return</span> {\n    a:<span class=\"hljs-number\">11</span>\n  }\n})\napp.injector(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">test</span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(test.a)\n})</code></pre><h2>angular依赖注入的实现：</h2><p>以上只是JS实现一个简单的依赖注入Demo。我们看一下angular中的依赖注入式怎么实现的：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-keyword\">var</span> ARROW_ARG = <span class=\"hljs-regexp\">/^([^(]+?)=&gt;/</span>;<span class=\"hljs-comment\">//箭头函数  ()=&gt;</span>\n<span class=\"hljs-keyword\">var</span> FN_ARGS = <span class=\"hljs-regexp\">/^[^(]*\\(\\s*([^)]*)\\)/m</span>;\n<span class=\"hljs-keyword\">var</span> FN_ARG_SPLIT = <span class=\"hljs-regexp\">/,/</span>;\n<span class=\"hljs-keyword\">var</span> FN_ARG = <span class=\"hljs-regexp\">/^\\s*(_?)(\\S+?)\\1\\s*$/</span>;\n<span class=\"hljs-keyword\">var</span> STRIP_COMMENTS = <span class=\"hljs-regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;\n<span class=\"hljs-keyword\">var</span> $injectorMinErr = minErr(<span class=\"hljs-string\">'$injector'</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">stringifyFn</span>(<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Function</span>.prototype.toString.call(fn);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extractArgs</span>(<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-comment\">//去除注释</span>\n  <span class=\"hljs-keyword\">var</span> fnText = stringifyFn(fn).replace(STRIP_COMMENTS, <span class=\"hljs-string\">''</span>),\n  <span class=\"hljs-comment\">//拿参数</span>\n    args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);\n  <span class=\"hljs-keyword\">return</span> args;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">anonFn</span>(<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-comment\">// For anonymous functions, showing at the very least the function signature can help in</span>\n  <span class=\"hljs-comment\">// debugging.</span>\n  <span class=\"hljs-keyword\">var</span> args = extractArgs(fn);\n  <span class=\"hljs-keyword\">if</span> (args) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'function('</span> + (args[<span class=\"hljs-number\">1</span>] || <span class=\"hljs-string\">''</span>).replace(<span class=\"hljs-regexp\">/[\\s\\r\\n]+/</span>, <span class=\"hljs-string\">' '</span>) + <span class=\"hljs-string\">')'</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'fn'</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">annotate</span>(<span class=\"hljs-params\">fn, strictDi, name</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> $inject,\n    argDecl,\n    last;\n  \n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> fn === <span class=\"hljs-string\">'function'</span>) {  <span class=\"hljs-comment\">//function($scope)</span>\n    <span class=\"hljs-keyword\">if</span> (!($inject = fn.$inject)) {\n      $inject = [];\n      <span class=\"hljs-keyword\">if</span> (fn.length) {\n        <span class=\"hljs-keyword\">if</span> (strictDi) {\n          <span class=\"hljs-keyword\">if</span> (!isString(name) || !name) {\n            name = fn.name || anonFn(fn);\n          }\n          <span class=\"hljs-keyword\">throw</span> $injectorMinErr(<span class=\"hljs-string\">'strictdi'</span>,\n            <span class=\"hljs-string\">'{0} is not using explicit annotation and cannot be invoked in strict mode'</span>, name);\n        }\n        argDecl = extractArgs(fn);\n        forEach(argDecl[<span class=\"hljs-number\">1</span>].split(FN_ARG_SPLIT), <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arg</span>) </span>{\n          arg.replace(FN_ARG, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">all, underscore, name</span>) </span>{\n            $inject.push(name);\n          });\n        });\n      }\n      fn.$inject = $inject;\n    }\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isArray(fn)) {<span class=\"hljs-comment\">//[\"$scope\",function($scope)]</span>\n    last = fn.length - <span class=\"hljs-number\">1</span>;\n    assertArgFn(fn[last], <span class=\"hljs-string\">'fn'</span>);\n    $inject = fn.slice(<span class=\"hljs-number\">0</span>, last);\n  } <span class=\"hljs-keyword\">else</span> {\n    assertArgFn(fn, <span class=\"hljs-string\">'fn'</span>, <span class=\"hljs-literal\">true</span>);\n  }\n  <span class=\"hljs-keyword\">return</span> $inject;\n}</code></pre><p>一上来先声明一系列的正则表达式，所以能<font color=\"#ff0000\">看得懂正则是阅读源码的必备技能</font>呀。以上代码是对注入参数的一系列处理，ng的声明注入有两种方式一种是数组式[\"$scope\",function($scope){}],一种是直接注入function($scope)上面代码分情况处理了一下。再看一下angular的注入部分：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createInternalInjector</span>(<span class=\"hljs-params\">cache, factory</span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getService</span>(<span class=\"hljs-params\">serviceName, caller</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (cache.hasOwnProperty(serviceName)) { <span class=\"hljs-comment\">//获取已存在的service</span>\n      <span class=\"hljs-keyword\">if</span> (cache[serviceName] === INSTANTIATING) {\n        <span class=\"hljs-keyword\">throw</span> $injectorMinErr(<span class=\"hljs-string\">'cdep'</span>, <span class=\"hljs-string\">'Circular dependency found: {0}'</span>,\n          serviceName + <span class=\"hljs-string\">' &lt;- '</span> + path.join(<span class=\"hljs-string\">' &lt;- '</span>));\n      }\n      <span class=\"hljs-keyword\">return</span> cache[serviceName];\n    } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">//不存在的话尝试创建</span>\n      <span class=\"hljs-keyword\">try</span> {\n        path.unshift(serviceName);\n        cache[serviceName] = INSTANTIATING;\n        cache[serviceName] = factory(serviceName, caller);\n        <span class=\"hljs-keyword\">return</span> cache[serviceName];\n      } <span class=\"hljs-keyword\">catch</span> (err) {\n        <span class=\"hljs-keyword\">if</span> (cache[serviceName] === INSTANTIATING) {\n          <span class=\"hljs-keyword\">delete</span> cache[serviceName];\n        }\n        <span class=\"hljs-keyword\">throw</span> err;\n      } <span class=\"hljs-keyword\">finally</span> {\n        path.shift();\n      }\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">injectionArgs</span>(<span class=\"hljs-params\">fn, locals, serviceName</span>) </span>{<span class=\"hljs-comment\">//获取注入的modlue</span>\n    <span class=\"hljs-keyword\">var</span> args = [],\n      $inject = createInjector.$annotate(fn, strictDi, serviceName);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>, length = $inject.length; i &lt; length; i++) {\n      <span class=\"hljs-keyword\">var</span> key = $inject[i];\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> key !== <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">throw</span> $injectorMinErr(<span class=\"hljs-string\">'itkn'</span>,\n          <span class=\"hljs-string\">'Incorrect injection token! Expected service name as string, got {0}'</span>, key);\n      }\n      args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? locals[key] :\n        getService(key, serviceName));\n    }\n    <span class=\"hljs-keyword\">return</span> args;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isClass</span>(<span class=\"hljs-params\">func</span>) </span>{\n    <span class=\"hljs-comment\">// Support: IE 9-11 only</span>\n    <span class=\"hljs-comment\">// IE 9-11 do not support classes and IE9 leaks with the code below.</span>\n    <span class=\"hljs-keyword\">if</span> (msie || <span class=\"hljs-keyword\">typeof</span> func !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n    <span class=\"hljs-keyword\">var</span> result = func.$ngIsClass;\n    <span class=\"hljs-keyword\">if</span> (!isBoolean(result)) {\n      <span class=\"hljs-comment\">// Support: Edge 12-13 only</span>\n      <span class=\"hljs-comment\">// See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/6156135/</span>\n      result = func.$ngIsClass = <span class=\"hljs-regexp\">/^(?:class\\b|constructor\\()/</span>.test(stringifyFn(func));\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">invoke</span>(<span class=\"hljs-params\">fn, self, locals, serviceName</span>) </span>{<span class=\"hljs-comment\">// 注入module</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> locals === <span class=\"hljs-string\">'string'</span>) {\n      serviceName = locals;\n      locals = <span class=\"hljs-literal\">null</span>;\n    }\n\n    <span class=\"hljs-keyword\">var</span> args = injectionArgs(fn, locals, serviceName);\n    <span class=\"hljs-keyword\">if</span> (isArray(fn)) {\n      fn = fn[fn.length - <span class=\"hljs-number\">1</span>];\n    }\n\n    <span class=\"hljs-keyword\">if</span> (!isClass(fn)) {\n      <span class=\"hljs-comment\">// http://jsperf.com/angularjs-invoke-apply-vs-switch</span>\n      <span class=\"hljs-comment\">// #5388</span>\n      <span class=\"hljs-keyword\">return</span> fn.apply(self, args);<span class=\"hljs-comment\">//调用注入的function 并注入所需module</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      args.unshift(<span class=\"hljs-literal\">null</span>);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span>(<span class=\"hljs-built_in\">Function</span>.prototype.bind.apply(fn, args))();\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">instantiate</span>(<span class=\"hljs-params\">Type, locals, serviceName</span>) </span>{\n    <span class=\"hljs-comment\">// Check if Type is annotated and use just the given function at n-1 as parameter</span>\n    <span class=\"hljs-comment\">// e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);</span>\n    <span class=\"hljs-keyword\">var</span> ctor = (isArray(Type) ? Type[Type.length - <span class=\"hljs-number\">1</span>] : Type);\n    <span class=\"hljs-keyword\">var</span> args = injectionArgs(Type, locals, serviceName);\n    <span class=\"hljs-comment\">// Empty object at position 0 is ignored for invocation with `new`, but required.</span>\n    args.unshift(<span class=\"hljs-literal\">null</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span>(<span class=\"hljs-built_in\">Function</span>.prototype.bind.apply(ctor, args))();\n  }\n}</code></pre><p>以上就是angular依赖注入的一部分，它考虑个更多的问题很情况，已经对$provider各种类型的处理，其实大致原理和最初所描述的差不太多，只是放在一个大的功能里面要考虑和依赖的东西更多一些。对于源码的阅读我觉得弄懂它的思想和理解代码大致的实现就可以了，完全弄懂的话需要对整个上下文都能贯通，当然，能弄懂的越多就学习的越多啦。只要思想对路子对，然后就是代码奇技淫巧的实现。</p><h3><font color=\"#008080\">以上都是个人理解，可能有些地方不对希望不要误导他人。</font></h3><p><br></p>",
  "intro" : "Angular爬坑学习（依赖注入）",
  "time" : "2017-04-27",
  "__v" : 0
}
